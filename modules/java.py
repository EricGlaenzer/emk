import os
import logging
import re
import shutil
import hashlib

log = logging.getLogger("emk.java")
utils = emk.module("utils")

need_depdirs = {}
dir_cache = {}

comments_regex = re.compile(r'(/\*.*?\*/)|(//.*?$)', re.MULTILINE | re.DOTALL)
package_regex = re.compile(r'package\s+(\S+)\s*;')
main_function_regex = re.compile(r'((public\s+static)|(static\s+public))\s+void\s+main\s*\(')

fix_path_regex = re.compile(r'[\W]+')

class Module(object):
    """
    emk module for compiling Java code and creating jar files. Depends on the utils module.
    
    This module will autodetect .java files in the current directory, compile them (with javac) and create
    a jar file out of the compiled classes. It will also autodetect classes that contain a main() method;
    for each class with a main() method, the java module will create an executable jar (name <class name>.jar)
    that can be run using "java -jar <class name>.jar".
    
    Note that autodetection of main() methods will only work if the main() method is in the toplevel class in the
    .java file (ie, it won't work if the main() method is in a static inner class). However you can explicitly
    define classes that contain a main() method using the 'exe_classes' property.
    
    Currently, the jar_in_jar/exe_jar_in_jar properties will only cause the emk-managed dependency jar contents
    to be included in the jar file - this does not include the 'sysjars' (ie, jar files that are built externally to emk).
    
    Properties (inherited from parent scope):
      javac_cmd -- The path to the java compiler. The default value is "javac".
      jar_cmd   -- The path to the jar utility. The default value is "jar".
      
      compile_flags -- Additional flags to pass to the java compiler. If you have a 'flag' that is more than one argument,
                       pass it as a tuple. Duplicate flags will be removed.
      exts          -- A list of file extensions (suffixes) for autodetection of Java source code. The default value is [".java"].
      source_files  -- A list of explicitly defined Java source files to compile.
  
      autodetect              -- If True, the java module will autodetect Java source code to compile based on the file name suffix.
      autodetect_from_targets -- If True, then the autodetection of Java source files will include files generated by rules
                                 in this directory. The default value is True.
      excludes                -- A list of files that should not be compiled, even if they are autodetected.
      
      exe_classes         -- A list of fully-qualified class names that contain valid main() methods. These will be built into
                             executable jar files.
      exclude_exe_classes -- A list of fully-qualified class names that should not be considered for executables, even if
                             they contain a valid main() method.
      autodetect_exe      -- If True, the java module will autodetect classes that contain valid main() methods and build them
                             into executable jar files. The default value is True.
      
      resources -- A list of (source path, relative jar path) tuples for resources to be added to the jar file.
                   The source path is the path of the file or directory that will be added to the jar file;
                   the relative jar path is that path relative to the jar file root where the source will be added.
      
      make_jar       -- If True, all compiled java classes in the current directory will be added into a single jar file.
                        The default jar file path is <build dir>/<directory name>.jar. The default value is True.
      jarname        -- If not None, this string will be used as the jar name instead of the name of the current directory.
                        The default value is None.
      jar_in_jar     -- If True, the contents of all jar dependencies (ie, from depdirs and projdirs) will be included in the generated
                        jar file for the current directory (assuming make_jar is True). The default value is False.
      exe_jar_in_jar -- If True, the contents of all jar dependencies (ie, from depdirs and projdirs) will be included in the generated
                        jar files for executable classes (to allow a self-contained jar executable). The default value is True.
      unique_names   -- If True, the output jar files will be named according to the path from the project directory, to avoid
                        naming conflicts when the build directory is not a relative path. The default value is False.
      
      depdirs      -- A list of directories that the java files in this directory depend on. The java module will instruct emk
                      to recurse into these directories, and the java classes in those directories will be compiled before
                      the java files in the current directory. When compiling java files, these directories will be added
                      to the classpath. Currently, circular directory dependencies are not supported for java.
      projdirs     -- A list of dependency directories (like depdirs) that are resolved relative to the project directory.
      sysjars      -- A set of other jar files that the java files in this directory depend on. Will be added to the classpath.
    """
    def __init__(self, scope, parent=None):
        self._abs_depdirs = set()
        self._classpaths = set()
        self._jar_contents = set()
        self._sysjars = set()
        
        self._class_dir = None
        self._resource_dir = None
        self._jar_dir = None
        
        self._depended_by = set()
        
        if parent:
            self.javac_cmd = parent.javac_cmd
            self.jar_cmd = parent.jar_cmd
            
            self.compile_flags = list(parent.compile_flags)
            self.exts = list(parent.exts)
            self.source_files = list(parent.source_files)
        
            self.autodetect = parent.autodetect
            self.autodetect_from_targets = parent.autodetect_from_targets
            self.excludes = list(parent.excludes)
            
            self.exe_classes = list(parent.exe_classes)
            self.exclude_exe_classes = list(parent.exclude_exe_classes)
            self.autodetect_exe = parent.autodetect_exe
            
            self.resources = list(parent.resources)
            
            self.make_jar = parent.make_jar
            self.jarname = parent.jarname
            self.jar_in_jar = parent.jar_in_jar
            self.exe_jar_in_jar = parent.exe_jar_in_jar
            self.unique_names = parent.unique_names
            
            self.depdirs = list(parent.depdirs)
            self.projdirs = list(parent.projdirs)
            self.sysjars = list(parent.sysjars)
        else:
            self.javac_cmd = "javac"
            self.jar_cmd = "jar"
            
            self.compile_flags = []
            self.exts = [".java"]
            self.source_files = []
        
            self.autodetect = True
            self.autodetect_from_targets = True
            self.excludes = []
            
            self.exe_classes = []
            self.exclude_exe_classes = []
            self.autodetect_exe = True
            
            self.resources = []
            
            self.make_jar = True
            self.jarname = None
            self.jar_in_jar = False
            self.exe_jar_in_jar = True
            self.unique_names = False
            
            self.depdirs = []
            self.projdirs = []
            self.sysjars = []
    
    def new_scope(self, scope):
        return Module(scope, parent=self)
    
    def _matches_exts(self, file_path, exts):
        for ext in exts:
            if file_path.endswith(ext):
                return True
        return False
    
    def post_rules(self):
        if emk.cleaning:
            return
        
        emk.do_prebuild(self._prebuild)
    
    def _examine_source(self, sourcefile):
        global comments_regex
        package = None
        main = False
        with open(sourcefile) as f:
            data = f.read()
            text = comments_regex.sub('', data)
            if main_function_regex.search(text):
                main = True
            pm = package_regex.search(text)
            if pm:
                package = pm.group(1).split('.')
        return (main, package)
    
    def _get_needed_by(self, d, result):
        global dir_cache
        result.add(d)
        for sub in dir_cache[d]._depended_by:
            if not sub in result:
                self._get_needed_by(sub, result)
    
    def _prebuild(self):
        global need_depdirs
        global dir_cache
        
        for d in self.projdirs:
            self.depdirs.append(os.path.join(emk.proj_dir, d))
        self.projdirs = []
        
        self._abs_depdirs = set([emk.abspath(d) for d in self.depdirs])
        
        for d in self._abs_depdirs:
            emk.recurse(d)
            
        sources = set()
        
        if self.autodetect:
            if self.autodetect_from_targets:
                target_files = [t for t in emk.local_targets.keys() if self._matches_exts(t, self.exts)]
                if target_files:
                    log.debug("Detected generated Java files: %s", target_files)
                    self.source_files.extend(target_files)
                    
            files = [f for f in os.listdir(emk.scope_dir) if os.path.isfile(f)]
            for file_path in files:
                if self._matches_exts(file_path, self.exts):
                    self.source_files.append(file_path)
        
        for f in self.source_files:
            if not f in self.excludes:
                sources.add(f)
                
        if self.autodetect_exe:
            for source in sources:
                m, p = self._examine_source(source)
                if m:
                    fname = os.path.basename(source)
                    name, ext = os.path.splitext(fname)
                    if p:
                        p.append(name)
                        fqn = '.'.join(p)
                    else:
                        fqn = name
                    self.exe_classes.append(fqn)
        exe_class_set = set(self.exe_classes)
        exe_class_set -= set(self.exclude_exe_classes)
        
        if self.resources:
            resource_set = set(self.resources)
            resource_sources, resource_dests = zip(*resource_set)
            emk.rule(self._copy_resources, "java.__jar_resources__", resource_sources, resource_dests, threadsafe=True, ex_safe=True)
        else:
            utils.mark_virtual_rule(["java.__jar_resources__"], [])
        
        emk.rule(self._build_classes, "java.__jar_contents__", sources, threadsafe=True)
        deps = [os.path.join(d, "java.__jar_contents__") for d in self._abs_depdirs]
        emk.depend("java.__jar_contents__", deps)
        emk.depend("java.__jar_contents__", "java.__jar_resources__")
        
        hash = hashlib.md5(emk.scope_dir).hexdigest()
        self._class_dir = os.path.join(emk.scope_dir, emk.build_dir, "java_classes_" + hash)
        self._resource_dir = os.path.join(emk.scope_dir, emk.build_dir, "java_resources_" + hash)
        self._jar_dir = os.path.join(emk.scope_dir, emk.build_dir)
        
        dirname = os.path.basename(emk.scope_dir)
        if self.unique_names:
            dirname = fix_path_regex.sub('_', os.path.relpath(emk.scope_dir, emk.proj_dir))
        jarname = dirname + ".jar"
        if self.jarname:
            jarname = self.jarname
        jarpath = os.path.join(self._jar_dir, jarname)
        if self.make_jar:
            emk.rule(self._make_jar, jarpath, "java.__jar_contents__", self.jar_in_jar, threadsafe=True, ex_safe=True)
            emk.alias(jarpath, jarname)
            emk.autobuild(jarpath)
        
        if exe_class_set:
            exe_jarpath = jarpath + "_exe"
            if self.make_jar and self.jar_in_jar == self.exe_jar_in_jar:
                exe_jarpath = jarpath
            else:
                emk.rule(self._make_jar, exe_jarpath, "java.__jar_contents__", self.exe_jar_in_jar, threadsafe=True, ex_safe=True)
            for exe in exe_class_set:
                if self.unique_names:
                    dirname = fix_path_regex.sub('_', os.path.relpath(emk.scope_dir, emk.proj_dir))
                    specific_jarname = dirname + "_" + exe + ".jar"
                else:
                    specific_jarname = exe + ".jar"
                specific_jarpath = os.path.join(self._jar_dir, specific_jarname)
                emk.rule(self._make_exe_jar, specific_jarpath, exe_jarpath, exe, threadsafe=True, ex_safe=True)
                emk.alias(specific_jarpath, specific_jarname)
                emk.autobuild(specific_jarpath)
        
        self._classpaths = set([self._class_dir])
        self._jar_contents = set([self._class_dir, self._resource_dir])
        self._sysjars = set([emk.abspath(j) for j in self.sysjars])
        for d in self._abs_depdirs:
            if d in dir_cache:
                cache = dir_cache[d]
                self._classpaths |= cache._classpaths
                self._jar_contents |= cache._jar_contents
                self._sysjars |= cache._sysjars
                cache._depended_by.add(emk.scope_dir)
            elif d in need_depdirs:
                need_depdirs[d].add(emk.scope_dir)
            else:
                need_depdirs[d] = set([emk.scope_dir])
        
        needed_by = set()
        if emk.scope_dir in need_depdirs:
            for d in need_depdirs[emk.scope_dir]:
                self._depended_by.add(d)
                self._get_needed_by(d, needed_by)
        
        for d in needed_by:
            cache = dir_cache[d]
            cache._classpaths |= self._classpaths
            cache._jar_contents |= self._jar_contents
            cache._sysjars |= self._sysjars
        
        dir_cache[emk.scope_dir] = self
    
    def _copy_resources(self, produces, requires, dests):
        for dest, src in zip(dests, requires):
            d, n = os.path.split(dest)
            if not n:
                n = os.path.basename(src)
            dest_dir = os.path.join(self._resource_dir, d)
            utils.mkdirs(dest_dir)
            dest = os.path.join(dest_dir, n)
            utils.rm(dest)
            os.symlink(src, dest)
        
        emk.mark_virtual("java.__jar_resources__")
    
    def _build_classes(self, produces, requires):
        global dir_cache
        
        utils.mkdirs(self._class_dir)
    
        if requires:
            classpath = ':'.join(self._classpaths | self._sysjars)
    
            cmd = [self.javac_cmd, "-d", self._class_dir, "-sourcepath", emk.scope_dir, "-classpath", classpath]
            cmd.extend(utils.flatten(self.compile_flags))
            cmd.extend(requires)
            utils.call(cmd)
        emk.mark_virtual("java.__jar_contents__")
        
    def _make_jar(self, produces, requires, jar_in_jar):
        jarfile = produces[0]
        
        dirset = set([self._class_dir, self._resource_dir])
        if jar_in_jar:
            dirset = self._jar_contents
        dirs = [(d, "") for d in dirset]
        
        entries = {}
        visited_dirs = set()
        while dirs:
            copy = dirs
            dirs = []
            for d, relpath in copy:
                if d in visited_dirs:
                    continue
                visited_dirs.add(d)
                
                if os.path.isdir(d):
                    subs = os.listdir(d)
                    for f in subs:
                        path = os.path.join(d, f)
                        if os.path.isfile(path):
                            entries[os.path.join(relpath, f)] = path
                        else:
                            dirs.append((path, os.path.join(relpath, f)))
        
        if entries:
            jarfile_contents = jarfile + ".contents"
            utils.rm(jarfile_contents)
            utils.mkdirs(jarfile_contents)
        
            for relpath, srcpath in entries.items():
                destpath = os.path.join(jarfile_contents, relpath)
                utils.mkdirs(os.path.dirname(destpath))
                os.symlink(srcpath, destpath)
        
            cmd = [self.jar_cmd, "cf", jarfile, "-C", jarfile_contents, "."]
            try:
                utils.call(cmd)
                utils.call(self.jar_cmd, "i", jarfile)
            except:
                utils.rm(jarfile)
                raise
        else:
            log.warning("Not making %s, since it has no contents", jarfile)
            emk.mark_virtual(jarfile)
    
    def _make_exe_jar(self, produces, requires, exe_class):
        dest = produces[0]
        src = requires[0]
        try:
            shutil.copy2(src, dest)
        
            manifest = dest + ".manifest"
            with open(manifest, "w") as f:
                f.write("Main-Class: " + exe_class + '\n')
        
            utils.call(self.jar_cmd, "ufm", dest, manifest)
        except:
            utils.rm(dest)
            raise
        